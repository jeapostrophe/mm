#lang racket/base
(require (for-syntax racket/base
                     racket/syntax)
         racket/contract/base
         rackunit/chk
         racket/bool
         racket/list
         mm)

(define-syntax (chkm stx)
  (syntax-case stx ()
    [(_ e v)
     (with-syntax ([c (generate-temporary 'collector)])
       (quasisyntax/loc stx
         (λ (c)
           (chk #,(syntax/loc stx (mutator-run/tight c e))
                v))))]
    [(_ e #:exn v)
     (with-syntax ([c (generate-temporary 'collector)])
       (quasisyntax/loc stx
         (λ (c)
           (chk #:exn
                #,(syntax/loc stx (mutator-run/tight c e))
                v))))]))

(define (run-suite size->collector)
  (define cache (make-hasheq))
  (define (cached-size->collector size)
    (hash-ref! cache size (λ () (size->collector size))))
  (for ([m (in-list ms)])
    (m cached-size->collector)))

(provide
 (contract-out
  [run-suite
   (-> (-> exact-nonnegative-integer? collector/c)
       void?)]))

(define ms
  (list
   (chkm (mutator 1)
         1)
   (chkm (mutator #t)
         #t)
   (chkm (mutator #f)
         #f)
   (chkm (mutator empty)
         '())
   (chkm (mutator '1)
         1)
   (chkm (mutator '#t)
         #t)
   (chkm (mutator '#f)
         #f)
   (chkm (mutator '())
         '())
   (chkm (mutator '(1 2))
         '(1 2))
   (chkm (mutator ((λ (x) x) 1))
         1)
   (chkm (mutator ((λ (x y) (+ x y)) 2 3))
         5)
   (chkm (mutator (let ([x 1]) x))
         1)
   (chkm (mutator (let* ([x 1] [y x]) y))
         1)
   (chkm (mutator (begin))
         (void))
   (chkm (mutator (begin 1))
         1)
   (chkm (mutator (begin 1 2))
         2)
   (chkm (mutator (let ([x (box 1)]) (set-box! x 2) (unbox x)))
         2)
   (chkm (mutator (letrec ([x 1]) x))
         1)
   (chkm (mutator (empty? '()))
         #t)
   (chkm (mutator (empty? 1))
         #f)
   (chkm (mutator (if #t 1 2))
         1)
   (chkm (mutator (if #f 1 2))
         2)
   (chkm (mutator (letrec ([len
                            (λ (l)
                              (if (empty? l)
                                0
                                (+ 1 (len (rest l)))))])
                    (len '(1 2 3))))
         3)
   (chkm (mutator (define (len l)
                    (if (empty? l)
                      0
                      (+ 1 (len (rest l)))))
                  (len '(1 2 3)))
         3)
   (chkm (mutator (define x 1)
                  x)
         1)
   (chkm (mutator (define x 1)
                  x
                  (define y 2)
                  (+ x y))
         3)
   (chkm (mutator (+ 1 2))
         3)
   (chkm (mutator (- 1 2))
         -1)
   (chkm (mutator (* 1 2))
         2)
   (chkm (mutator (/ 1 2))
         1/2)
   (chkm (mutator (sub1 2))
         1)
   (chkm (mutator (add1 2))
         3)
   (chkm (mutator (and))
         #t)
   (chkm (mutator (and #t))
         #t)
   (chkm (mutator (and 1))
         1)
   (chkm (mutator (and 1 2))
         2)
   (chkm (mutator (or))
         #f)
   (chkm (mutator (or #t))
         #t)
   (chkm (mutator (or 1))
         1)
   (chkm (mutator (or #f 1))
         1)
   (chkm (mutator (or #f 1 2))
         1)
   (chkm (mutator (or 1 2))
         1)
   (chkm (mutator (or #f 2))
         2)
   (chkm (mutator (cond))
         (void))
   (chkm (mutator (cond [else 1]))
         1)
   (chkm (mutator (cond [#f 2] [else 1]))
         1)
   (chkm (mutator (cond [2 1] [else 3]))
         1)
   (chkm (mutator "string")
         "string")
   (chkm (mutator (string=? "string" "string"))
         #t)
   (chkm (mutator (string=? "string" "stringx"))
         #f)
   (chkm (mutator 'symbol)
         'symbol)
   (chkm (mutator (symbol=? 'symbol 'symbol))
         #t)
   (chkm (mutator (symbol=? 'symbol 'symbolx))
         #f)
   (chkm (mutator (= 1 2))
         #f)
   (chkm (mutator (= 1 1))
         #t)
   (chkm (mutator (equal? 1 1))
         #t)
   (chkm (mutator (equal? 1 2))
         #f)
   (chkm (mutator (equal? '(1 2) '(1)))
         #f)
   (chkm (mutator (equal? '(1 2) '(1 2)))
         #t)
   (chkm (mutator (printf "Hey there, ~a\n" "Jay"))
         (void))
   (chkm (mutator (error 'test "Hey there, ~a\n" "Jay"))
         #:exn
         "Jay")
   (chkm (mutator (define x (cons 1 2))
                  (eq? x x))
         #t)
   (chkm (mutator (not #t))
         #f)
   (chkm (mutator (not #f))
         #t)
   (chkm (mutator (when #t 1))
         1)
   (chkm (mutator (when #f 1))
         (void))
   (chkm (mutator (unless #t 1))
         (void))
   (chkm (mutator (unless #f 1))
         1)
   (chkm (mutator (test (+ 1 2) 3))
         (void))
   (chkm (mutator (test (+ 1 2) 4))
         #:exn
         "not equal")
   (chkm (mutator (unbox (box 1)))
         1)

   (chkm (mutator 1 2 3)
         3)
   (chkm (mutator 1 2 3 (cons 4 5))
         (cons 4 5))
   (chkm (mutator 1 2 3 (cons 4 5) 6)
         6)
   (chkm (mutator 1 2 3 (cons (cons 4 5) 6))
         (cons (cons 4 5) 6))
   (chkm (mutator (box 1) 2)
         2)
   (chkm (mutator (cons (box 1) 2))
         (cons (box 1) 2))
   (chkm (mutator (define x (cons 1 2))
                  (set-rest! x x)
                  3 4
                  (first x))
         1)
   (chkm (mutator (define (len l)
                    (if (empty? l)
                      0
                      (add1 (len (rest l)))))
                  (define (sum l)
                    (if (empty? l)
                      0
                      (+ (first l)
                         (sum (rest l)))))

                  (define x
                    '(1 2 3 4 5))
                  (+ (len x)
                     (sum x)))
         (+ 5 (+ 1 2 3 4 5)))
   (chkm (mutator (define (my-even? x)
                    (if (zero? x)
                      #t
                      (my-odd? (sub1 x))))
                  (define (my-odd? x)
                    (if (zero? x)
                      #f
                      (my-even? (sub1 x))))
                  (my-even? 14))
         #t)))
